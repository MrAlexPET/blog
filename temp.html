import os, json, time, socket, sys
from datetime import datetime
from pathlib import Path
import pyodbc

# === НАСТРОЙКИ ===
XEL_GLOB = r"C:\XEvents\siem_exoerp_queries*.xel"

BASE_DIR = Path(sys.executable).resolve().parent if getattr(sys, "frozen", False) else Path(__file__).resolve().parent
STATE_PATH = str(BASE_DIR / "mssql-exoerp-xevent.offset.json")

SYSLOG_HOST = "10.181.18.24"
SYSLOG_PORT = 616
SYSLOG_PROTO = "udp"  # "udp" или "tcp" (если нужно tcp — скажи, дам готовую tcp-реализацию)

HOSTNAME = socket.gethostname()
APP_NAME = "MSSQLXEvent"

FACILITY = 16  # local0
DEFAULT_SEVERITY = 6

POLL_SECONDS = 1.0
BATCH_SIZE = 2000


def pri(severity: int) -> int:
    return FACILITY * 8 + severity


def rfc3339_now_local():
    return datetime.now().astimezone().isoformat(timespec="milliseconds")


def make_rfc5424(payload: str, severity: int, msgid: str):
    return f"<{pri(severity)}>1 {rfc3339_now_local()} {HOSTNAME} {APP_NAME} - {msgid} - {payload}"


def load_state():
    try:
        with open(STATE_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        return {"file": "", "offset": 0}


def save_state(st: dict):
    os.makedirs(os.path.dirname(STATE_PATH), exist_ok=True)
    with open(STATE_PATH, "w", encoding="utf-8") as f:
        json.dump(st, f)


def connect_sql():
    conn_str = (
        "DRIVER={ODBC Driver 17 for SQL Server};"
        "SERVER=localhost;"
        "Trusted_Connection=yes;"
        "TrustServerCertificate=yes;"
    )
    return pyodbc.connect(conn_str, autocommit=True)


READ_SQL = r"""
DECLARE @path NVARCHAR(4000) = ?;

;WITH xe AS (
    SELECT TOP (?)
        f.file_name,
        f.file_offset,
        CAST(f.event_data AS XML) AS x
    FROM sys.fn_xe_file_target_read_file(@path, NULL, NULL, NULL) AS f
),
rows AS (
    SELECT
        file_name,
        file_offset,

        x.value('(/event/@name)[1]','nvarchar(200)') AS event_name,
        x.value('(/event/@timestamp)[1]','datetime2(7)') AS ts_utc,

        x.value('(/event/action[@name="database_name"]/value)[1]','nvarchar(256)') AS database_name,
        x.value('(/event/action[@name="client_app_name"]/value)[1]','nvarchar(512)') AS client_app_name,
        x.value('(/event/action[@name="client_hostname"]/value)[1]','nvarchar(256)') AS client_hostname,
        x.value('(/event/action[@name="server_principal_name"]/value)[1]','nvarchar(256)') AS server_principal_name,
        x.value('(/event/action[@name="nt_username"]/value)[1]','nvarchar(256)') AS nt_username,
        x.value('(/event/action[@name="session_id"]/value)[1]','int') AS session_id,

        x.value('(/event/action[@name="sql_text"]/value)[1]','nvarchar(max)') AS sql_text,

        x.value('(/event/data[@name="duration"]/value)[1]','bigint') AS duration,
        x.value('(/event/data[@name="cpu_time"]/value)[1]','bigint') AS cpu_time,
        x.value('(/event/data[@name="logical_reads"]/value)[1]','bigint') AS logical_reads,
        x.value('(/event/data[@name="writes"]/value)[1]','bigint') AS writes,

        x.value('(/event/data[@name="statement"]/value)[1]','nvarchar(max)') AS statement,
        x.value('(/event/data[@name="batch_text"]/value)[1]','nvarchar(max)') AS batch_text
    FROM xe
)
SELECT *
FROM rows
ORDER BY file_name, file_offset;
"""


def should_skip(row, state):
    f = row.file_name or ""
    off = int(row.file_offset or 0)
    if f < state["file"]:
        return True
    if f == state["file"] and off <= int(state["offset"]):
        return True
    return False


class SyslogSender:
    def __init__(self):
        self.sock = None
        self.tcp_connected = False
        self._init_socket()

    def _init_socket(self):
        if SYSLOG_PROTO.lower() == "udp":
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        else:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(5)

    def send(self, msg: str):
        data = (msg + "\n").encode("utf-8", errors="replace")
        if SYSLOG_PROTO.lower() == "udp":
            self.sock.sendto(data, (SYSLOG_HOST, SYSLOG_PORT))
            return

        # TCP (минимальная поддержка, без сложной ретрансляции)
        if not self.tcp_connected:
            self.sock.connect((SYSLOG_HOST, SYSLOG_PORT))
            self.tcp_connected = True
        self.sock.sendall(data)


def main():
    state = load_state()
    sender = SyslogSender()

    conn = connect_sql()
    cur = conn.cursor()

    while True:
        cur.execute(READ_SQL, (XEL_GLOB, BATCH_SIZE))
        rows = cur.fetchall()

        last_file = state["file"]
        last_off = state["offset"]
        sent = 0

        for r in rows:
            if should_skip(r, state):
                continue

            text = r.statement or r.sql_text or r.batch_text or ""

            payload = {
                "src": "mssql_xevent",
                "event_name": r.event_name,
                "ts_utc": r.ts_utc.isoformat() if r.ts_utc else None,

                "database": r.database_name,
                "client_app": r.client_app_name,
                "client_host": r.client_hostname,
                "login": r.server_principal_name,
                "nt_user": r.nt_username,
                "session_id": r.session_id,

                "duration": int(r.duration) if r.duration is not None else None,
                "cpu_time": int(r.cpu_time) if r.cpu_time is not None else None,
                "logical_reads": int(r.logical_reads) if r.logical_reads is not None else None,
                "writes": int(r.writes) if r.writes is not None else None,

                "query": text,
                "xel_file": r.file_name,
                "xel_offset": int(r.file_offset or 0),
                "forwarded_ts": rfc3339_now_local(),
            }

            msgid = f"mssql_{(r.event_name or 'event').lower()}"
            msg = make_rfc5424(json.dumps(payload, ensure_ascii=False), DEFAULT_SEVERITY, msgid)

            sender.send(msg)

            last_file = r.file_name
            last_off = int(r.file_offset or 0)
            sent += 1

        if sent > 0:
            state["file"] = last_file
            state["offset"] = last_off
            save_state(state)

        time.sleep(POLL_SECONDS)


if __name__ == "__main__":
    main()