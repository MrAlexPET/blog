sudo tee /opt/pg_csv_to_siem.py >/dev/null <<'EOF'
#!/usr/bin/env python3
import os, csv, json, time, socket, sys, io
from datetime import datetime
from pathlib import Path

# --------- CONFIG ----------
LOG_FILE = "/opt/log/pgpro/ent-16/pg_log/postgresql-current.csv.csv"  # ваш текущий файл
POLL_SEC = 0.2

SYSLOG_HOST = "10.181.18.24"
SYSLOG_PORT = 616
SOCKET_TIMEOUT_SEC = 10
TCP_RECONNECT_DELAY_SEC = 2

HOSTNAME = socket.gethostname()
APP_NAME = "PostgreSQLGeneralLog"
FACILITY = 16  # local0

CHUNK_SIZE = 64 * 1024

# если запись битая и "не закрываются кавычки", буфер будет расти.
# при превышении лимита делаем resync (пропускаем до следующей \n)
MAX_BUFFER_BYTES = 8 * 1024 * 1024
RESYNC_SCAN_LIMIT_BYTES = 1024 * 1024
# --------------------------

BASE_DIR = Path(sys.executable).resolve().parent if getattr(sys, "frozen", False) else Path(__file__).resolve().parent
STATE_PATH = str(BASE_DIR / "postgresql-csv.offset")

SEV_MAP = {
    "DEBUG": 7, "DEBUG1": 7, "DEBUG2": 7, "DEBUG3": 7, "DEBUG4": 7, "DEBUG5": 7,
    "INFO": 6, "NOTICE": 5, "LOG": 6,
    "WARNING": 4, "ERROR": 3, "FATAL": 2, "PANIC": 0,
}
DEFAULT_SEVERITY = 6

COLS = [
    "log_time","user_name","database_name","process_id","connection_from",
    "session_id","session_line_num","command_tag","session_start_time",
    "virtual_transaction_id","transaction_id","error_severity","sql_state_code",
    "message","detail","hint","internal_query","internal_query_pos","context",
    "query","query_pos","location","application_name","backend_type","leader_pid",
    "query_id"
]

def log(msg):
    ts = datetime.now().astimezone().isoformat(timespec="seconds")
    print(f"{ts} {msg}", flush=True)

def pri(severity: int) -> int:
    return FACILITY * 8 + severity

def rfc3339_now_local():
    return datetime.now().astimezone().isoformat(timespec="milliseconds")

def make_rfc5424(payload: str, severity: int, msgid: str):
    return f"<{pri(severity)}>1 {rfc3339_now_local()} {HOSTNAME} {APP_NAME} - {msgid} - {payload}"

def load_state(expected_path: str) -> int:
    try:
        with open(STATE_PATH, "r", encoding="utf-8") as f:
            s = f.read().strip()
        if not s:
            return 0
        parts = s.split("|", 1)
        if len(parts) != 2:
            return 0
        path, off = parts[0], parts[1]
        if path != expected_path:
            return 0
        return int(off)
    except FileNotFoundError:
        return 0
    except Exception:
        return 0

def save_state(path: str, off: int):
    os.makedirs(os.path.dirname(STATE_PATH), exist_ok=True)
    with open(STATE_PATH, "w", encoding="utf-8") as f:
        f.write(f"{path}|{off}")

def extract_argument_from_message(msg: str) -> str:
    if not msg:
        return ""
    if msg.startswith("execute "):
        p = msg.find(": ")
        if p != -1:
            return msg[p+2:]
        return msg
    if msg.startswith("statement: "):
        return msg[len("statement: "):]
    return msg

def normalize_event(row):
    d = {}
    for i, name in enumerate(COLS):
        if i < len(row) and row[i] != "":
            d[name] = row[i]

    cmd = d.get("command_tag", "pg") or "pg"
    msgid = ("pg_" + cmd).lower()

    payload = {
        "src": "postgresql_csvlog",
        "ts": d.get("log_time"),
        "thread_id": d.get("process_id"),
        "cmd": cmd,
        "argument": extract_argument_from_message(d.get("message", "")),
        "forwarded_ts": None,
    }
    return payload, msgid, d.get("error_severity")

def tcp_connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(SOCKET_TIMEOUT_SEC)
    s.connect((SYSLOG_HOST, SYSLOG_PORT))
    s.settimeout(SOCKET_TIMEOUT_SEC)  # важно: sendall не должен висеть вечно
    return s

def send_syslog_tcp_rfc6587(sock, payload_obj: dict, msgid: str, severity_name: str):
    sev = SEV_MAP.get((severity_name or "").upper(), DEFAULT_SEVERITY)
    payload_obj["forwarded_ts"] = rfc3339_now_local()
    payload = json.dumps(payload_obj, ensure_ascii=False)

    msg = make_rfc5424(payload, severity=sev, msgid=msgid)
    msg_bytes = msg.encode("utf-8", errors="replace")
    frame = str(len(msg_bytes)).encode("ascii") + b" " + msg_bytes
    sock.sendall(frame)

def try_parse_one_record(buf: bytes):
    """
    Пытается распарсить одну CSV запись из начала буфера.
    Возвращает (row, consumed_bytes) или (None, 0) если нужно больше данных.
    Стратегия:
      - ищем очередной '\n' в bytes
      - пробуем распарсить candidate (до этого '\n' включительно)
      - если не получилось (вероятно \n внутри кавычек) -> ищем следующий '\n'
    """
    start = 0
    while True:
        nl = buf.find(b"\n", start)
        if nl == -1:
            return None, 0

        candidate = buf[:nl+1]
        try:
            text = candidate.decode("utf-8", errors="replace")
            rows = list(csv.reader([text]))
            if len(rows) == 1:
                return rows[0], nl+1
        except Exception:
            pass

        start = nl + 1

def resync(buf: bytes):
    """
    Ресинк при битой записи: пропустить до следующего '\n' (в пределах лимита),
    иначе выбросить кусок лимита.
    Возвращает (new_buf, dropped_bytes)
    """
    if not buf:
        return buf, 0
    scan = buf[:RESYNC_SCAN_LIMIT_BYTES]
    nl = scan.find(b"\n")
    if nl != -1:
        return buf[nl+1:], nl+1
    drop = min(len(buf), RESYNC_SCAN_LIMIT_BYTES)
    return buf[drop:], drop

def follow():
    tcp_sock = None
    offset = load_state(LOG_FILE)
    buf = b""

    sent = 0
    skipped = 0
    decode_repl = 0
    last_stat = time.time()

    log(f"start file={LOG_FILE} offset={offset}")

    while True:
        # connect/reconnect
        if tcp_sock is None:
            try:
                tcp_sock = tcp_connect()
                log(f"tcp connected to {SYSLOG_HOST}:{SYSLOG_PORT}")
            except Exception as e:
                log(f"tcp connect failed: {e}")
                tcp_sock = None
                time.sleep(TCP_RECONNECT_DELAY_SEC)
                continue

        if not os.path.exists(LOG_FILE):
            time.sleep(1)
            continue

        try:
            with open(LOG_FILE, "rb") as fb:
                # если файл ротировался/обнулился и стал меньше
                try:
                    size = os.path.getsize(LOG_FILE)
                    if size < offset:
                        log(f"file truncated: size={size} < offset={offset}, reset offset=0")
                        offset = 0
                        save_state(LOG_FILE, offset)
                except Exception:
                    pass

                fb.seek(offset)
                chunk = fb.read(CHUNK_SIZE)
                if not chunk:
                    time.sleep(POLL_SEC)
                    continue

                buf += chunk

                # если буфер стал огромным — ресинк, иначе можно зависнуть навсегда
                if len(buf) > MAX_BUFFER_BYTES:
                    buf, dropped = resync(buf)
                    offset += dropped
                    save_state(LOG_FILE, offset)
                    skipped += 1
                    log(f"resync: buf>{MAX_BUFFER_BYTES}, dropped_bytes={dropped}, offset={offset}")

                # парсим сколько можем
                while True:
                    row, consumed = try_parse_one_record(buf)
                    if row is None:
                        break

                    # нормализация
                    try:
                        payload_obj, msgid, sevname = normalize_event(row)
                    except Exception as e:
                        # битая запись — пропускаем
                        buf = buf[consumed:]
                        offset += consumed
                        save_state(LOG_FILE, offset)
                        skipped += 1
                        log(f"skip normalize error at offset={offset}: {e}")
                        continue

                    # отправка
                    try:
                        send_syslog_tcp_rfc6587(tcp_sock, payload_obj, msgid, sevname)
                    except (socket.timeout, BrokenPipeError, ConnectionResetError, ConnectionAbortedError, OSError) as e:
                        log(f"send failed (reconnect): {e}")
                        try:
                            tcp_sock.close()
                        except Exception:
                            pass
                        tcp_sock = None
                        # consumed НЕ коммитим, чтобы запись ушла после реконнекта
                        break

                    # успех: коммит
                    buf = buf[consumed:]
                    offset += consumed
                    save_state(LOG_FILE, offset)
                    sent += 1

        except Exception as e:
            log(f"read loop error: {e}")
            time.sleep(1)

        now = time.time()
        if now - last_stat >= 60:
            # оценка replace-символов: дешёвая проверка по наличию bytes 0xEF 0xBF 0xBD невозможна без декода,
            # поэтому просто печатаем буфер/offset/счётчики
            log(f"stat: sent={sent} skipped={skipped} offset={offset} buf_bytes={len(buf)}")
            last_stat = now

if __name__ == "__main__":
    follow()
EOF