#!/usr/bin/env python3
import os, csv, json, time, socket, sys
from datetime import datetime
from pathlib import Path

# ---------------- CONFIG ----------------
LOG_DIR = "/opt/log/pgpro/ent-16/pg_log"
LOG_BASENAME_TEMPLATE = "postgresql-%Y-%m-%d.csv.csv"   # как у вас: всегда .csv.csv
POLL_SEC = 0.2

SYSLOG_HOST = "10.181.18.24"
SYSLOG_PORT = 616
SOCKET_TIMEOUT_SEC = 10
TCP_RECONNECT_DELAY_SEC = 2

HOSTNAME = socket.gethostname()
APP_NAME = "PostgreSQLGeneralLog"
FACILITY = 16  # local0

CHUNK_SIZE = 64 * 1024

# Если запись битая (незакрытые кавычки/мусор), буфер будет расти.
# При превышении лимита делаем resync и продолжаем.
MAX_BUFFER_BYTES = 8 * 1024 * 1024
RESYNC_SCAN_LIMIT_BYTES = 1024 * 1024

# Пишем статистику в journald
STAT_EVERY_SEC = 60
# ----------------------------------------

BASE_DIR = Path(sys.executable).resolve().parent if getattr(sys, "frozen", False) else Path(__file__).resolve().parent
STATE_PATH = str(BASE_DIR / "postgresql-csv.offset")

SEV_MAP = {
    "DEBUG": 7, "DEBUG1": 7, "DEBUG2": 7, "DEBUG3": 7, "DEBUG4": 7, "DEBUG5": 7,
    "INFO": 6, "NOTICE": 5, "LOG": 6,
    "WARNING": 4, "ERROR": 3, "FATAL": 2, "PANIC": 0,
}
DEFAULT_SEVERITY = 6

COLS = [
    "log_time","user_name","database_name","process_id","connection_from",
    "session_id","session_line_num","command_tag","session_start_time",
    "virtual_transaction_id","transaction_id","error_severity","sql_state_code",
    "message","detail","hint","internal_query","internal_query_pos","context",
    "query","query_pos","location","application_name","backend_type","leader_pid",
    "query_id"
]

def log(msg: str):
    ts = datetime.now().astimezone().isoformat(timespec="seconds")
    print(f"{ts} {msg}", flush=True)

def current_log_file() -> str:
    return os.path.join(LOG_DIR, datetime.now().strftime(LOG_BASENAME_TEMPLATE))

def pri(severity: int) -> int:
    return FACILITY * 8 + severity

def rfc3339_now_local():
    return datetime.now().astimezone().isoformat(timespec="milliseconds")

def make_rfc5424(payload: str, severity: int, msgid: str):
    return f"<{pri(severity)}>1 {rfc3339_now_local()} {HOSTNAME} {APP_NAME} - {msgid} - {payload}"

def load_state(expected_path: str) -> int:
    """
    Формат: path|byte_offset
    Если path не совпал — считаем, что новый файл -> offset=0
    """
    try:
        with open(STATE_PATH, "r", encoding="utf-8") as f:
            s = f.read().strip()
        if not s:
            return 0
        parts = s.split("|", 1)
        if len(parts) != 2:
            return 0
        path, off = parts[0], parts[1]
        if path != expected_path:
            return 0
        return int(off)
    except FileNotFoundError:
        return 0
    except Exception:
        return 0

def save_state(path: str, off: int):
    os.makedirs(os.path.dirname(STATE_PATH), exist_ok=True)
    with open(STATE_PATH, "w", encoding="utf-8") as f:
        f.write(f"{path}|{off}")

def extract_argument_from_message(msg: str) -> str:
    if not msg:
        return ""
    if msg.startswith("execute "):
        p = msg.find(": ")
        if p != -1:
            return msg[p+2:]
        return msg
    if msg.startswith("statement: "):
        return msg[len("statement: "):]
    return msg

def normalize_event(row):
    d = {}
    for i, name in enumerate(COLS):
        if i < len(row) and row[i] != "":
            d[name] = row[i]

    cmd = d.get("command_tag", "pg") or "pg"
    msgid = ("pg_" + cmd).lower()

    payload = {
        "src": "postgresql_csvlog",
        "ts": d.get("log_time"),
        "thread_id": d.get("process_id"),
        "cmd": cmd,
        "argument": extract_argument_from_message(d.get("message", "")),
        "forwarded_ts": None,
    }
    return payload, msgid, d.get("error_severity")

def tcp_connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(SOCKET_TIMEOUT_SEC)
    s.connect((SYSLOG_HOST, SYSLOG_PORT))
    s.settimeout(SOCKET_TIMEOUT_SEC)  # sendall() не должен висеть вечно
    return s

def send_syslog_tcp_rfc6587(sock, payload_obj: dict, msgid: str, severity_name: str):
    sev = SEV_MAP.get((severity_name or "").upper(), DEFAULT_SEVERITY)
    payload_obj["forwarded_ts"] = rfc3339_now_local()
    payload = json.dumps(payload_obj, ensure_ascii=False)

    msg = make_rfc5424(payload, severity=sev, msgid=msgid)
    msg_bytes = msg.encode("utf-8", errors="replace")
    frame = str(len(msg_bytes)).encode("ascii") + b" " + msg_bytes
    sock.sendall(frame)

def try_parse_one_record(buf: bytes):
    """
    Пытается распарсить одну CSV запись из начала буфера.
    Возвращает (row, consumed_bytes) или (None, 0) если нужно больше данных.
    """
    start = 0
    while True:
        nl = buf.find(b"\n", start)
        if nl == -1:
            return None, 0

        candidate = buf[:nl+1]
        try:
            # csvlog в UTF-8, на мусоре заменим на U+FFFD, но запись всё равно может распарситься
            text = candidate.decode("utf-8", errors="replace")
            rows = list(csv.reader([text]))
            if len(rows) == 1:
                return rows[0], nl+1
        except Exception:
            pass

        start = nl + 1

def resync(buf: bytes):
    """
    Если буфер раздувается (обычно из-за битой записи с незакрытыми кавычками),
    пропускаем до ближайшего '\n' (в пределах лимита), иначе выкидываем кусок лимита.
    """
    if not buf:
        return buf, 0
    scan = buf[:RESYNC_SCAN_LIMIT_BYTES]
    nl = scan.find(b"\n")
    if nl != -1:
        return buf[nl+1:], nl+1
    drop = min(len(buf), RESYNC_SCAN_LIMIT_BYTES)
    return buf[drop:], drop

def follow():
    tcp_sock = None
    path = current_log_file()
    offset = load_state(path)
    buf = b""

    sent = 0
    skipped = 0
    last_stat = time.time()

    log(f"start path={path} offset={offset}")

    while True:
        # смена файла по дате (после 00:00)
        new_path = current_log_file()
        if new_path != path:
            path = new_path
            offset = load_state(path)  # будет 0, т.к. path новый
            buf = b""
            log(f"switched to new log file: path={path} offset={offset}")

        # connect/reconnect
        if tcp_sock is None:
            try:
                tcp_sock = tcp_connect()
                log(f"tcp connected to {SYSLOG_HOST}:{SYSLOG_PORT}")
            except Exception as e:
                log(f"tcp connect failed: {e}")
                tcp_sock = None
                time.sleep(TCP_RECONNECT_DELAY_SEC)
                continue

        if not os.path.exists(path):
            time.sleep(1)
            continue

        try:
            # если файл обнулили/пересоздали и он меньше offset
            try:
                size = os.path.getsize(path)
                if size < offset:
                    log(f"file truncated: size={size} < offset={offset}, reset offset=0")
                    offset = 0
                    save_state(path, offset)
                    buf = b""
            except Exception:
                pass

            with open(path, "rb") as fb:
                fb.seek(offset)
                chunk = fb.read(CHUNK_SIZE)
                if not chunk:
                    time.sleep(POLL_SEC)
                    continue

                buf += chunk

                # защита от "вечного ожидания" окончания битой записи
                if len(buf) > MAX_BUFFER_BYTES:
                    buf, dropped = resync(buf)
                    offset += dropped
                    save_state(path, offset)
                    skipped += 1
                    log(f"resync: buf>{MAX_BUFFER_BYTES}, dropped_bytes={dropped}, offset={offset}")

                # парсим сколько можем
                while True:
                    row, consumed = try_parse_one_record(buf)
                    if row is None:
                        break

                    # нормализация
                    try:
                        payload_obj, msgid, sevname = normalize_event(row)
                    except Exception as e:
                        buf = buf[consumed:]
                        offset += consumed
                        save_state(path, offset)
                        skipped += 1
                        log(f"skip normalize error at offset={offset}: {e}")
                        continue

                    # отправка
                    try:
                        send_syslog_tcp_rfc6587(tcp_sock, payload_obj, msgid, sevname)
                    except (socket.timeout, BrokenPipeError, ConnectionResetError, ConnectionAbortedError, OSError) as e:
                        log(f"send failed (reconnect): {e}")
                        try:
                            tcp_sock.close()
                        except Exception:
                            pass
                        tcp_sock = None
                        # consumed НЕ коммитим, чтобы запись ушла после реконнекта
                        break

                    # успех
                    buf = buf[consumed:]
                    offset += consumed
                    save_state(path, offset)
                    sent += 1

        except Exception as e:
            log(f"read loop error: {e}")
            time.sleep(1)

        now = time.time()
        if now - last_stat >= STAT_EVERY_SEC:
            log(f"stat: path={path} sent={sent} skipped={skipped} offset={offset} buf_bytes={len(buf)}")
            last_stat = now

if __name__ == "__main__":
    follow()
EOF
