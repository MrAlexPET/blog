import socket
import threading
import struct
import mss
from PIL import Image
import io
import time

HOST = "0.0.0.0"
PORT = 5000

client_connected = False

def handle_client(conn):
    global client_connected
    with mss.mss() as sct:
        monitor = sct.monitors[1]

        try:
            while True:
                screenshot = sct.grab(monitor)
                img = Image.frombytes("RGB", screenshot.size, screenshot.rgb)

                buffer = io.BytesIO()
                img.save(buffer, format="JPEG", quality=60)
                data = buffer.getvalue()

                # Отправляем размер кадра (4 байта)
                conn.sendall(struct.pack(">I", len(data)))
                # Отправляем сам кадр
                conn.sendall(data)

                time.sleep(0.05)  # ~20 FPS
        except:
            print("Клиент отключился")

    conn.close()
    client_connected = False


def start_server():
    global client_connected
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind((HOST, PORT))
    server.listen(1)

    print(f"Сервер запущен на порту {PORT}")

    while True:
        conn, addr = server.accept()

        if client_connected:
            print("Попытка второго подключения — отклонено")
            conn.close()
            continue

        print(f"Подключен клиент: {addr}")
        client_connected = True

        threading.Thread(target=handle_client, args=(conn,), daemon=True).start()


if __name__ == "__main__":
    start_server()



import socket
import struct
import tkinter as tk
from PIL import Image, ImageTk
import io
import threading

SERVER_IP = "192.168.0.100"  # <-- ВСТАВЬ IP ПК-2
PORT = 5000

class RemoteClient:
    def __init__(self, root):
        self.root = root
        self.root.title("Remote Desktop")
        self.label = tk.Label(root)
        self.label.pack()

        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((SERVER_IP, PORT))

        threading.Thread(target=self.receive_video, daemon=True).start()

    def receive_video(self):
        try:
            while True:
                size_data = self.recvall(4)
                size = struct.unpack(">I", size_data)[0]

                frame_data = self.recvall(size)
                image = Image.open(io.BytesIO(frame_data))

                photo = ImageTk.PhotoImage(image)

                self.label.config(image=photo)
                self.label.image = photo
        except:
            print("Соединение закрыто")

    def recvall(self, size):
        data = b""
        while len(data) < size:
            packet = self.sock.recv(size - len(data))
            if not packet:
                return None
            data += packet
        return data


if __name__ == "__main__":
    root = tk.Tk()
    app = RemoteClient(root)
    root.mainloop()
