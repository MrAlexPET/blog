server.py:
import ctypes
ctypes.windll.user32.SetProcessDPIAware()

import socket
import threading
import struct
import mss
from PIL import Image
import io
import time
from pynput.mouse import Controller as MouseController, Button
from pynput.keyboard import Controller as KeyboardController
import json
import pyautogui

with mss.mss() as sct:
    monitor = sct.monitors[1]
    SCREEN_WIDTH = monitor["width"]
    SCREEN_HEIGHT = monitor["height"]

HOST = "0.0.0.0"
VIDEO_PORT = 5000
CONTROL_PORT = 5001

# SCREEN_WIDTH, SCREEN_HEIGHT = pyautogui.size()

client_connected = False

mouse = MouseController()
keyboard = KeyboardController()


# ================= VIDEO =================

def video_stream(conn):
    with mss.mss() as sct:
        # monitor = sct.monitors[1]

        try:
            while True:
                screenshot = sct.grab(monitor)
                img = Image.frombytes("RGB", screenshot.size, screenshot.rgb)

                buffer = io.BytesIO()
                img.save(buffer, format="JPEG", quality=60)
                data = buffer.getvalue()

                conn.sendall(struct.pack(">I", len(data)))
                conn.sendall(data)

                time.sleep(0.03)

        except Exception as e:
            print("Видео соединение закрыто:", e)

    conn.close()


# ================= CONTROL =================

def control_handler(conn):
    try:
        screen_info = json.dumps({
            "width": SCREEN_WIDTH,
            "height": SCREEN_HEIGHT
        }).encode()

        conn.sendall(struct.pack(">I", len(screen_info)))
        conn.sendall(screen_info)
        while True:
            header = conn.recv(1)
            if not header:
                break

            packet_type = struct.unpack("B", header)[0]

            size_data = conn.recv(4)
            size = struct.unpack(">I", size_data)[0]

            data = conn.recv(size)
            message = json.loads(data.decode())

            if packet_type == 2:  # движение мыши
                mouse.position = (message["x"], message["y"])

            elif packet_type == 3:  # клик
                if message["action"] == "down":
                    mouse.press(Button.left)
                else:
                    mouse.release(Button.left)

            elif packet_type == 4:  # клавиша
                key = message["key"]
                keyboard.press(key)
                keyboard.release(key)

            elif packet_type == 5:  # колесо
                mouse.scroll(0, int(message["delta"] / 120))

            elif packet_type == 6:  # пкм
                if message["action"] == "down":
                    mouse.press(Button.right)
                else:
                    mouse.release(Button.right)

            elif packet_type == 7:  # передача файлов
                filename = message["filename"]
                filesize = message["size"]

                print(f"Получаю файл {filename}, размер {filesize} байт")

                with open(filename, "wb") as f:
                    remaining = filesize
                    while remaining > 0:
                        chunk_size = 65536 if remaining >= 65536 else remaining
                        chunk = conn.recv(chunk_size)
                        if not chunk:
                            break
                        f.write(chunk)
                        remaining -= len(chunk)

                print(f"Файл {filename} успешно получен")

    except Exception as e:
        print("Control соединение закрыто:", e)

    conn.close()


# ================= SERVER =================

def start_server():
    # print(pyautogui.size())
    global client_connected

    video_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    control_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    video_server.bind((HOST, VIDEO_PORT))
    control_server.bind((HOST, CONTROL_PORT))

    video_server.listen(1)
    control_server.listen(1)

    print("Сервер запущен")
    print("Видео порт:", VIDEO_PORT)
    print("Контроль порт:", CONTROL_PORT)

    while True:
        video_conn, video_addr = video_server.accept()

        if client_connected:
            video_conn.close()
            continue

        print("Видео подключено:", video_addr)

        control_conn, control_addr = control_server.accept()
        print("Контроль подключен:", control_addr)

        client_connected = True

        threading.Thread(target=video_stream, args=(video_conn,), daemon=True).start()
        threading.Thread(target=control_handler, args=(control_conn,), daemon=True).start()


if __name__ == "__main__":
    start_server()




=============================
client.py:
import os.path
import socket
import struct
import tkinter as tk
from tkinter import filedialog, messagebox
from PIL import Image, ImageTk
import io
import threading
import json

SERVER_IP = "169.254.36.5"
VIDEO_PORT = 5000
CONTROL_PORT = 5001


class RemoteClient:
    def __init__(self, root):
        self.root = root
        self.root.title("Remote Desktop")

        # ====== Видео ======
        self.label = tk.Label(root)
        self.label.pack(fill="both", expand=True)
        self.root.geometry("1280x720")

        # Кнопка отправки файлов
        self.send_file_btn = tk.Button(root, text="Отправить файл", command=self.choose_and_send_file)
        self.send_file_btn.pack(side="bottom", pady=5)

        # Видео сокет
        self.video_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.video_sock.connect((SERVER_IP, VIDEO_PORT))

        # Сокет управления
        self.control_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.control_sock.connect((SERVER_IP, CONTROL_PORT))

        # Получаем размер удаленного экрана
        size_data = self.recvall(self.control_sock, 4)
        size = struct.unpack(">I", size_data)[0]
        screen_data = self.recvall(self.control_sock, size)
        screen_info = json.loads(screen_data.decode())

        self.remote_width = screen_info["width"]
        self.remote_height = screen_info["height"]

        self.label.bind("<Motion>", self.on_mouse_move)
        self.label.bind("<ButtonPress-1>", self.on_mouse_click)
        self.label.bind("<ButtonRelease-1>", self.on_mouse_release)
        self.label.bind("<MouseWheel>", self.on_mouse_wheel)
        self.label.bind("<ButtonPress-3>", self.on_right_click_down)
        self.label.bind("<ButtonRelease-3>", self.on_right_click_up)
        self.root.bind("<KeyPress>", self.on_key_press)

        threading.Thread(target=self.receive_video, daemon=True).start()

    # ================= VIDEO =================

    def receive_video(self):
        try:
            while True:
                size_data = self.recvall(self.video_sock, 4)
                if not size_data:
                    break

                size = struct.unpack(">I", size_data)[0]
                frame_data = self.recvall(self.video_sock, size)

                image = Image.open(io.BytesIO(frame_data))
                photo = ImageTk.PhotoImage(image)

                self.label.config(image=photo)
                self.label.image = photo

                self.video_width, self.video_height = image.size

        except Exception as e:
            print("Видео соединение закрыто:", e)

    def recvall(self, sock, size):
        data = b""
        while len(data) < size:
            packet = sock.recv(size - len(data))
            if not packet:
                return None
            data += packet
        return data

    # ================= CONTROL =================

    def send_packet(self, packet_type, data_dict):
        data = json.dumps(data_dict).encode()
        self.control_sock.sendall(struct.pack("B", packet_type))
        self.control_sock.sendall(struct.pack(">I", len(data)))
        self.control_sock.sendall(data)

    def on_mouse_move(self, event):
        self.send_mouse_position(event)

    def on_mouse_click(self, event):
        self.send_mouse_position(event)
        self.send_packet(3, {"action": "down"})

    def on_mouse_release(self, event):
        self.send_mouse_position(event)
        self.send_packet(3, {"action": "up"})

    def on_key_press(self, event):
        if event.char:
            self.send_packet(4, {"key": event.char})

    def on_mouse_wheel(self, event):
        self.send_packet(5, {"delta": event.delta})

    def on_right_click_down(self, event):
        self.send_packet(6, {"action": "down"})

    def on_right_click_up(self, event):
        self.send_packet(6, {"action": "up"})

    def send_mouse_position(self, event):
        if not hasattr(self, "video_width"):
            return

        label_width = self.label.winfo_width()
        label_height = self.label.winfo_height()

        # scale_x = self.remote_width / self.video_width
        # scale_y = self.remote_height / self.video_height

        scale_x = self.remote_width / label_width
        scale_y = self.remote_height / label_height

        real_x = int(event.x * scale_x)
        real_y = int(event.y * scale_y)

        self.send_packet(2, {"x": real_x, "y": real_y})

    def send_file(self, path):
        try:
            filename = os.path.basename(path)
            filesize = os.path.getsize(path)

            self.send_packet(7, {"filename": filename, "size": filesize})

            with open(path, "rb") as f:
                while True:
                    chunk = f.read(65535)
                    if not chunk:
                        break
                    self.control_sock.sendall(chunk)

            messagebox.showinfo("Готово", f"Файл {filename} успешно отправлен")
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось отправить файл:\n{e}")

    def choose_and_send_file(self):
        path = filedialog.askopenfilename()
        if path:
            threading.Thread(target=self.send_file, args=(path,), daemon=True).start()


if __name__ == "__main__":
    root = tk.Tk()
    app = RemoteClient(root)
    root.mainloop()



