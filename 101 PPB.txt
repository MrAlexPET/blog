import socket
import threading
import struct
import mss
from PIL import Image
import io
import time
from pynput.mouse import Controller as MouseController, Button
from pynput.keyboard import Controller as KeyboardController
import json

HOST = "0.0.0.0"
VIDEO_PORT = 5000
CONTROL_PORT = 5001

client_connected = False

mouse = MouseController()
keyboard = KeyboardController()


# ================= VIDEO =================

def video_stream(conn):
    with mss.mss() as sct:
        monitor = sct.monitors[1]

        try:
            while True:
                screenshot = sct.grab(monitor)
                img = Image.frombytes("RGB", screenshot.size, screenshot.rgb)

                buffer = io.BytesIO()
                img.save(buffer, format="JPEG", quality=60)
                data = buffer.getvalue()

                conn.sendall(struct.pack(">I", len(data)))
                conn.sendall(data)

                time.sleep(0.03)

        except Exception as e:
            print("Видео соединение закрыто:", e)

    conn.close()


# ================= CONTROL =================

def control_handler(conn):
    try:
        while True:
            header = conn.recv(1)
            if not header:
                break

            packet_type = struct.unpack("B", header)[0]

            size_data = conn.recv(4)
            size = struct.unpack(">I", size_data)[0]

            data = conn.recv(size)
            message = json.loads(data.decode())

            if packet_type == 2:  # движение мыши
                mouse.position = (message["x"], message["y"])

            elif packet_type == 3:  # клик
                if message["action"] == "down":
                    mouse.press(Button.left)
                else:
                    mouse.release(Button.left)

            elif packet_type == 4:  # клавиша
                key = message["key"]
                keyboard.press(key)
                keyboard.release(key)

    except Exception as e:
        print("Control соединение закрыто:", e)

    conn.close()


# ================= SERVER =================

def start_server():
    global client_connected

    video_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    control_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    video_server.bind((HOST, VIDEO_PORT))
    control_server.bind((HOST, CONTROL_PORT))

    video_server.listen(1)
    control_server.listen(1)

    print("Сервер запущен")
    print("Видео порт:", VIDEO_PORT)
    print("Контроль порт:", CONTROL_PORT)

    while True:
        video_conn, video_addr = video_server.accept()

        if client_connected:
            video_conn.close()
            continue

        print("Видео подключено:", video_addr)

        control_conn, control_addr = control_server.accept()
        print("Контроль подключен:", control_addr)

        client_connected = True

        threading.Thread(target=video_stream, args=(video_conn,), daemon=True).start()
        threading.Thread(target=control_handler, args=(control_conn,), daemon=True).start()


if __name__ == "__main__":
    start_server()



import socket
import struct
import tkinter as tk
from PIL import Image, ImageTk
import io
import threading
import json

SERVER_IP = "169.254.36.5"  # <-- твой IP
VIDEO_PORT = 5000
CONTROL_PORT = 5001


class RemoteClient:
    def __init__(self, root):
        self.root = root
        self.root.title("Remote Desktop")

        self.label = tk.Label(root)
        self.label.pack()

        # Видео сокет
        self.video_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.video_sock.connect((SERVER_IP, VIDEO_PORT))

        # Контроль сокет
        self.control_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.control_sock.connect((SERVER_IP, CONTROL_PORT))

        self.label.bind("<Motion>", self.on_mouse_move)
        self.label.bind("<ButtonPress-1>", self.on_mouse_click)
        self.label.bind("<ButtonRelease-1>", self.on_mouse_release)

        self.root.bind("<KeyPress>", self.on_key_press)

        threading.Thread(target=self.receive_video, daemon=True).start()

    # ================= VIDEO =================

    def receive_video(self):
        try:
            while True:
                size_data = self.recvall(self.video_sock, 4)
                if not size_data:
                    break

                size = struct.unpack(">I", size_data)[0]
                frame_data = self.recvall(self.video_sock, size)

                image = Image.open(io.BytesIO(frame_data))
                photo = ImageTk.PhotoImage(image)

                self.label.config(image=photo)
                self.label.image = photo

        except Exception as e:
            print("Видео соединение закрыто:", e)

    def recvall(self, sock, size):
        data = b""
        while len(data) < size:
            packet = sock.recv(size - len(data))
            if not packet:
                return None
            data += packet
        return data

    # ================= CONTROL =================

    def send_packet(self, packet_type, data_dict):
        data = json.dumps(data_dict).encode()
        self.control_sock.sendall(struct.pack("B", packet_type))
        self.control_sock.sendall(struct.pack(">I", len(data)))
        self.control_sock.sendall(data)

    def on_mouse_move(self, event):
        self.send_packet(2, {"x": event.x, "y": event.y})

    def on_mouse_click(self, event):
        self.send_packet(3, {"action": "down"})

    def on_mouse_release(self, event):
        self.send_packet(3, {"action": "up"})

    def on_key_press(self, event):
        if event.char:
            self.send_packet(4, {"key": event.char})


if __name__ == "__main__":
    root = tk.Tk()
    app = RemoteClient(root)
    root.mainloop()
