import socket
import threading
import struct
import mss
from PIL import Image
import io
import time
from pynput.mouse import Controller as MouseController, Button
from pynput.keyboard import Controller as KeyboardController
import json
import pyautogui

HOST = "0.0.0.0"
VIDEO_PORT = 5000
CONTROL_PORT = 5001

SCREEN_WIDTH, SCREEN_HEIGHT = pyautogui.size()

client_connected = False

mouse = MouseController()
keyboard = KeyboardController()


# ================= VIDEO =================

def video_stream(conn):
    with mss.mss() as sct:
        monitor = sct.monitors[1]

        try:
            while True:
                screenshot = sct.grab(monitor)
                img = Image.frombytes("RGB", screenshot.size, screenshot.rgb)

                buffer = io.BytesIO()
                img.save(buffer, format="JPEG", quality=60)
                data = buffer.getvalue()

                conn.sendall(struct.pack(">I", len(data)))
                conn.sendall(data)

                time.sleep(0.03)

        except Exception as e:
            print("Видео соединение закрыто:", e)

    conn.close()


# ================= CONTROL =================

def control_handler(conn):
    try:
        while True:
            header = conn.recv(1)
            if not header:
                break

            packet_type = struct.unpack("B", header)[0]

            size_data = conn.recv(4)
            size = struct.unpack(">I", size_data)[0]

            data = conn.recv(size)
            message = json.loads(data.decode())

            if packet_type == 2:  # движение мыши
                mouse.position = (message["x"], message["y"])

            elif packet_type == 3:  # клик
                if message["action"] == "down":
                    mouse.press(Button.left)
                else:
                    mouse.release(Button.left)

            elif packet_type == 4:  # клавиша
                key = message["key"]
                keyboard.press(key)
                keyboard.release(key)

            elif packet_type == 5:  # колесо
                mouse.scroll(0, int(message["delta"] / 120))

            elif packet_type == 6:  # пкм
                if message["action"] == "down":
                    mouse.press(Button.right)
                else:
                    mouse.release(Button.right)

    except Exception as e:
        print("Control соединение закрыто:", e)

    conn.close()


# ================= SERVER =================

def start_server():
    print(pyautogui.size())
    global client_connected

    video_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    control_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    video_server.bind((HOST, VIDEO_PORT))
    control_server.bind((HOST, CONTROL_PORT))

    video_server.listen(1)
    control_server.listen(1)

    print("Сервер запущен")
    print("Видео порт:", VIDEO_PORT)
    print("Контроль порт:", CONTROL_PORT)

    while True:
        video_conn, video_addr = video_server.accept()

        if client_connected:
            video_conn.close()
            continue

        print("Видео подключено:", video_addr)

        control_conn, control_addr = control_server.accept()
        print("Контроль подключен:", control_addr)

        client_connected = True

        threading.Thread(target=video_stream, args=(video_conn,), daemon=True).start()
        threading.Thread(target=control_handler, args=(control_conn,), daemon=True).start()


if __name__ == "__main__":
    start_server()


=============================

import socket
import struct
import tkinter as tk
from PIL import Image, ImageTk
import io
import threading
import json

SERVER_IP = "169.254.36.5"
VIDEO_PORT = 5000
CONTROL_PORT = 5001

SCREEN_WIDTH = 1920
SCREEN_HEIGHT = 955


class RemoteClient:
    def __init__(self, root):
        self.root = root
        self.root.title("Remote Desktop")

        self.label = tk.Label(root)
        self.label.pack()

        # Видео сокет
        self.video_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.video_sock.connect((SERVER_IP, VIDEO_PORT))

        # Сокет управления
        self.control_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.control_sock.connect((SERVER_IP, CONTROL_PORT))

        self.label.bind("<Motion>", self.on_mouse_move)
        self.label.bind("<ButtonPress-1>", self.on_mouse_click)
        self.label.bind("<ButtonRelease-1>", self.on_mouse_release)
        self.label.bind("<MouseWheel>", self.on_mouse_wheel)
        self.label.bind("<ButtonPress-3>", self.on_right_click_down)
        self.label.bind("<ButtonRelease-3>", self.on_right_click_up)

        self.root.bind("<KeyPress>", self.on_key_press)

        threading.Thread(target=self.receive_video, daemon=True).start()

    # ================= VIDEO =================

    def receive_video(self):
        try:
            while True:
                size_data = self.recvall(self.video_sock, 4)
                if not size_data:
                    break

                size = struct.unpack(">I", size_data)[0]
                frame_data = self.recvall(self.video_sock, size)

                image = Image.open(io.BytesIO(frame_data))
                photo = ImageTk.PhotoImage(image)

                self.label.config(image=photo)
                self.label.image = photo

                self.video_width, self.video_height = image.size

        except Exception as e:
            print("Видео соединение закрыто:", e)

    def recvall(self, sock, size):
        data = b""
        while len(data) < size:
            packet = sock.recv(size - len(data))
            if not packet:
                return None
            data += packet
        return data

    # ================= CONTROL =================

    def send_packet(self, packet_type, data_dict):
        data = json.dumps(data_dict).encode()
        self.control_sock.sendall(struct.pack("B", packet_type))
        self.control_sock.sendall(struct.pack(">I", len(data)))
        self.control_sock.sendall(data)

    def on_mouse_move(self, event):
        self.send_packet(2, {"x": event.x, "y": event.y})
        scale_x = SCREEN_WIDTH / self.video_width
        scale_y = SCREEN_HEIGHT / self.video_height

        real_x = int(event.x * scale_x)
        real_y = int(event.y * scale_y)

    def on_mouse_click(self, event):
        self.send_packet(3, {"action": "down"})

    def on_mouse_release(self, event):
        self.send_packet(3, {"action": "up"})

    def on_key_press(self, event):
        if event.char:
            self.send_packet(4, {"key": event.char})

    def on_mouse_wheel(self, event):
        self.send_packet(5, {"delta": event.delta})

    def on_right_click_down(self, event):
        self.send_packet(6, {"action": "down"})

    def on_right_click_up(self, event):
        self.send_packet(6, {"action": "up"})


if __name__ == "__main__":
    root = tk.Tk()
    app = RemoteClient(root)
    root.mainloop()
