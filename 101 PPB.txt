server.py:
import ctypes
ctypes.windll.user32.SetProcessDPIAware()

import socket
import threading
import struct
import mss
from PIL import Image
import io
import time
from pynput.mouse import Controller as MouseController, Button
from pynput.keyboard import Controller as KeyboardController
import json

with mss.mss() as sct:
    monitor = sct.monitors[1]
    SCREEN_WIDTH = monitor["width"]
    SCREEN_HEIGHT = monitor["height"]

HOST = "0.0.0.0"
VIDEO_PORT = 5000
CONTROL_PORT = 5001

client_connected = False

mouse = MouseController()
keyboard = KeyboardController()


# ================= VIDEO =================

def video_stream(conn):
    with mss.mss() as sct:

        try:
            while True:
                screenshot = sct.grab(monitor)
                img = Image.frombytes("RGB", screenshot.size, screenshot.rgb)

                buffer = io.BytesIO()
                img.save(buffer, format="JPEG", quality=60)
                data = buffer.getvalue()

                conn.sendall(struct.pack(">I", len(data)))
                conn.sendall(data)

                time.sleep(0.02)

        except Exception as e:
            print("Видео соединение закрыто:", e)

    conn.close()


# ================= CONTROL =================

def control_handler(conn):
    try:
        screen_info = json.dumps({
            "width": SCREEN_WIDTH,
            "height": SCREEN_HEIGHT
        }).encode()

        conn.sendall(struct.pack(">I", len(screen_info)))
        conn.sendall(screen_info)
        while True:
            header = recvall(conn, 1)
            if not header:
                break

            packet_type = struct.unpack("B", header)[0]

            size_data = recvall(conn, 4)
            if not size_data:
                break

            size = struct.unpack(">I", size_data)[0]

            data = recvall(conn, size)
            if not data:
                break

            message = json.loads(data.decode())

            if packet_type == 2:  # движение мыши
                mouse.position = (message["x"], message["y"])

            elif packet_type == 3:  # клик
                if message["action"] == "down":
                    mouse.press(Button.left)
                else:
                    mouse.release(Button.left)

            elif packet_type == 4:  # клавиша
                key = message["key"]
                keyboard.press(key)
                keyboard.release(key)

            elif packet_type == 5:  # колесо
                mouse.scroll(0, int(message["delta"] / 120))

            elif packet_type == 6:  # пкм
                if message["action"] == "down":
                    mouse.press(Button.right)
                else:
                    mouse.release(Button.right)

            elif packet_type == 7:  # передача файлов
                filename = message["filename"]
                filesize = message["size"]

                print(f"Получаю файл {filename}, размер {filesize} байт")


                try:
                    with open(filename, "wb") as f:
                        remaining = filesize
                        while remaining > 0:
                            # chunk_size = 65536 if remaining >= 65536 else remaining
                            # chunk = conn.recv(chunk_size)
                            chunk = conn.recv(min(65536, remaining))
                            if not chunk:
                                print(f"Клиент закрыл соединение во время передачи файла {filename}")
                                break
                            f.write(chunk)
                            remaining -= len(chunk)

                    print(f"Файл {filename} успешно получен")
                except Exception as e:
                    print(f"Ошибка при получении файла {filename}: {e}")
                continue

    except Exception as e:
        print("Control соединение закрыто:", e)

    conn.close()


def recvall(sock, size):
    data = b""
    while len(data) < size:
        packet = sock.recv(size - len(data))
        if not packet:
            return None
        data += packet
    return data


# ================= SERVER =================

def start_server():
    # print(pyautogui.size())
    global client_connected

    video_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    control_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    video_server.bind((HOST, VIDEO_PORT))
    control_server.bind((HOST, CONTROL_PORT))

    video_server.listen(1)
    control_server.listen(1)

    print("Сервер запущен")
    print("Видео порт:", VIDEO_PORT)
    print("Контроль порт:", CONTROL_PORT)

    while True:
        video_conn, video_addr = video_server.accept()

        if client_connected:
            video_conn.close()
            continue

        print("Видео подключено:", video_addr)

        control_conn, control_addr = control_server.accept()
        print("Контроль подключен:", control_addr)

        client_connected = True

        threading.Thread(target=video_stream, args=(video_conn,), daemon=True).start()
        threading.Thread(target=control_handler, args=(control_conn,), daemon=True).start()


if __name__ == "__main__":
    start_server()



=============================
client.py:
import os
import socket
import struct
import tkinter as tk
from tkinter import filedialog, messagebox
from PIL import Image, ImageTk
import io
import threading
import json

SERVER_IP = "169.254.36.5"
VIDEO_PORT = 5000
CONTROL_PORT = 5001


class RemoteClient:
    def __init__(self, root):
        self.root = root
        self.root.title("Remote Desktop")
        self.root.geometry("1280x720")

        # ======= GUI с grid =======
        self.root.rowconfigure(0, weight=1)
        self.root.columnconfigure(0, weight=1)

        # Видео
        self.label = tk.Label(root, bg="black")
        self.label.grid(row=0, column=0, sticky="nsew")

        # Кнопка отправки файлов
        self.send_file_btn = tk.Button(root, text="Отправить файл", command=self.choose_and_send_file)
        self.send_file_btn.grid(row=1, column=0, sticky="ew", pady=5)

        # ======= Сокеты =======
        self.video_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.video_sock.connect((SERVER_IP, VIDEO_PORT))

        self.control_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.control_sock.connect((SERVER_IP, CONTROL_PORT))

        # Получаем размер удаленного экрана
        size_data = self.recvall(self.control_sock, 4)
        size = struct.unpack(">I", size_data)[0]
        screen_data = self.recvall(self.control_sock, size)
        screen_info = json.loads(screen_data.decode())

        self.remote_width = screen_info["width"]
        self.remote_height = screen_info["height"]

        # ======= События управления =======
        self.label.bind("<Motion>", self.on_mouse_move)
        self.label.bind("<ButtonPress-1>", self.on_mouse_click)
        self.label.bind("<ButtonRelease-1>", self.on_mouse_release)
        self.label.bind("<MouseWheel>", self.on_mouse_wheel)
        self.label.bind("<ButtonPress-3>", self.on_right_click_down)
        self.label.bind("<ButtonRelease-3>", self.on_right_click_up)
        self.root.bind("<KeyPress>", self.on_key_press)

        # Поток видео
        threading.Thread(target=self.receive_video, daemon=True).start()

    # ================= VIDEO =================
    def receive_video(self):
        try:
            while True:
                size_data = self.recvall(self.video_sock, 4)
                if not size_data:
                    break
                size = struct.unpack(">I", size_data)[0]
                frame_data = self.recvall(self.video_sock, size)
                if not frame_data:
                    break

                image = Image.open(io.BytesIO(frame_data))
                self.video_width, self.video_height = image.size

                label_width = self.label.winfo_width()
                label_height = self.label.winfo_height()

                if label_width > 1 and label_height > 1:
                    ratio = min(label_width / self.video_width,
                                label_height / self.video_height)

                    new_width = int(self.video_width * ratio)
                    new_height = int(self.video_height * ratio)

                    image = image.resize((new_width, new_height))

                    self.display_width = new_width
                    self.display_height = new_height

                    self.offset_x = (label_width - new_width) // 2
                    self.offset_y = (label_height - new_height) // 2
                else:
                    self.display_width = self.video_width
                    self.display_height = self.video_height
                    self.offset_x = 0
                    self.offset_y = 0

                photo = ImageTk.PhotoImage(image)
                self.label.config(image=photo)
                self.label.image = photo

        except Exception as e:
            print("Видео соединение закрыто:", e)

    def recvall(self, sock, size):
        data = b""
        while len(data) < size:
            packet = sock.recv(size - len(data))
            if not packet:
                return None
            data += packet
        return data

    # ================= CONTROL =================
    def send_packet(self, packet_type, data_dict):
        data = json.dumps(data_dict).encode()
        self.control_sock.sendall(struct.pack("B", packet_type))
        self.control_sock.sendall(struct.pack(">I", len(data)))
        self.control_sock.sendall(data)

    def send_mouse_position(self, event):
        if not hasattr(self, "video_width"):
            return

        # Проверяем что клик внутри изображения
        if (event.x < self.offset_x or
                event.x > self.offset_x + self.display_width or
                event.y < self.offset_y or
                event.y > self.offset_y + self.display_height):
            return

        x = event.x - self.offset_x
        y = event.y - self.offset_y

        scale_x = self.remote_width / self.display_width
        scale_y = self.remote_height / self.display_height

        real_x = int(x * scale_x)
        real_y = int(y * scale_y)

        self.send_packet(2, {"x": real_x, "y": real_y})

    def on_mouse_move(self, event):
        self.send_mouse_position(event)

    def on_mouse_click(self, event):
        self.send_mouse_position(event)
        self.send_packet(3, {"action": "down"})

    def on_mouse_release(self, event):
        self.send_mouse_position(event)
        self.send_packet(3, {"action": "up"})

    def on_key_press(self, event):
        if event.char:
            self.send_packet(4, {"key": event.char})

    def on_mouse_wheel(self, event):
        self.send_packet(5, {"delta": event.delta})

    def on_right_click_down(self, event):
        self.send_packet(6, {"action": "down"})

    def on_right_click_up(self, event):
        self.send_packet(6, {"action": "up"})

    # ================= FILE =================
    def send_file(self, path):
        try:
            filename = os.path.basename(path)
            filesize = os.path.getsize(path)
            # Отправка мета
            self.send_packet(7, {"filename": filename, "size": filesize})
            # Отправка файла порциями
            with open(path, "rb") as f:
                while True:
                    chunk = f.read(65536)
                    if not chunk:
                        break
                    self.control_sock.sendall(chunk)
            messagebox.showinfo("Готово", f"Файл {filename} успешно отправлен")
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось отправить файл:\n{e}")

    def choose_and_send_file(self):
        path = filedialog.askopenfilename()
        if path:
            threading.Thread(target=self.send_file, args=(path,), daemon=True).start()


if __name__ == "__main__":
    root = tk.Tk()
    app = RemoteClient(root)
    root.mainloop()

